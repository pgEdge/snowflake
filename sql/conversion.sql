/*
 * A series of tests on transformation of serial and IDENTITY columns to the
 * Snowflake-default ones.
 */

\set VERBOSITY terse

SET snowflake.node = 1;

CREATE EXTENSION snowflake;

-- Need to check two types of serial values: DEFAULT and IDENTITY
CREATE TABLE t1(x serial);
CREATE TABLE t2 (x integer GENERATED ALWAYS AS IDENTITY);
CREATE TABLE t3 (x integer GENERATED BY DEFAULT AS IDENTITY,
				 y serial NOT NULL, z serial NOT NULL CHECK (y > 0));
CREATE SEQUENCE seq_1 START 42;

INSERT INTO t1 VALUES (DEFAULT);
INSERT INTO t2 VALUES (DEFAULT);
INSERT INTO t3 VALUES (DEFAULT);

SELECT snowflake.convert_sequence_to_snowflake('t1'); -- ERROR, not a sequence
SELECT snowflake.convert_sequence_to_snowflake('seq_1'); -- No associated relation found

SELECT snowflake.convert_sequence_to_snowflake('t1_x_seq');
SELECT snowflake.convert_sequence_to_snowflake('t2_x_seq');
SELECT snowflake.convert_sequence_to_snowflake('t3_x_seq');
SELECT snowflake.convert_sequence_to_snowflake('t3_z_seq'); -- non-default attnum

INSERT INTO t1 VALUES (DEFAULT);
INSERT INTO t2 VALUES (DEFAULT);
INSERT INTO t3 VALUES (DEFAULT);

-- Check the result of conversion
SELECT x <= 42 AS is_not_snowflake_value FROM t1 ORDER BY x;
SELECT x <= 42 AS is_not_snowflake_value FROM t2 ORDER BY x;
SELECT
	x <= 42 AS is_not_snowflake_value,
	y,
	z <= 42 AS is_not_snowflake_value
FROM t3 ORDER BY x;

ALTER TABLE t3 ALTER COLUMN y SET DEFAULT 1;
SELECT snowflake.convert_sequence_to_snowflake('t3_y_seq');
INSERT INTO t3 VALUES (DEFAULT);
SELECT
	x <= 42 AS is_not_snowflake_value,
	y,
	z <= 42 AS is_not_snowflake_value
FROM t3 ORDER BY x;

-- Manually set DEFAULT nextval for a column
ALTER TABLE t3 ALTER COLUMN y DROP DEFAULT;
SELECT snowflake.convert_sequence_to_snowflake('t3_y_seq'); -- Should be correctly ignored
ALTER TABLE t3 ALTER COLUMN y SET DEFAULT nextval('t3_y_seq'::regclass);
SELECT snowflake.convert_sequence_to_snowflake('t3_y_seq');
TRUNCATE t3;
INSERT INTO t3 VALUES (DEFAULT);
SELECT
	x <= 42 AS is_not_snowflake_value,
	y <= 42 AS is_not_snowflake_value,
	z <= 42 AS is_not_snowflake_value
FROM t3 ORDER BY x;

-- Manual usage of the snowflake default is also legal.
ALTER TABLE t3 ALTER COLUMN y DROP DEFAULT;
ALTER TABLE t3 ALTER COLUMN y SET DEFAULT snowflake.nextval('t3_y_seq'::regclass);
SELECT snowflake.convert_sequence_to_snowflake('t3_y_seq'); -- do not convert, it is already done manually
INSERT INTO t3 VALUES (DEFAULT);
SELECT
	x <= 42 AS is_not_snowflake_value,
	y <= 42 AS is_not_snowflake_value,
	z <= 42 AS is_not_snowflake_value
FROM t3 ORDER BY x;

-- Explict default
CREATE SEQUENCE favorite_seq;
CREATE TABLE t4 (x integer DEFAULT nextval('favorite_seq'::regclass));
INSERT INTO t4 values (DEFAULT);
SELECT * FROM t4;
SELECT snowflake.convert_sequence_to_snowflake('favorite_seq');
INSERT INTO t4 values (DEFAULT);
SELECT x <= 42 AS is_not_snowflake_value FROM t4 ORDER BY x;

-- Sequence, shared by two tables
DROP TABLE t4 CASCADE;
DROP SEQUENCE favorite_seq;
CREATE SEQUENCE favorite_seq;
CREATE TABLE t4 (x integer DEFAULT nextval('favorite_seq'::regclass));
INSERT INTO t4 values (DEFAULT);
CREATE TABLE t5 (x integer DEFAULT nextval('favorite_seq'::regclass));
INSERT INTO t5 values (DEFAULT);
SELECT * FROM t4;
SELECT * FROM t5;
SELECT snowflake.convert_sequence_to_snowflake('favorite_seq');
INSERT INTO t4 values (DEFAULT);
INSERT INTO t5 values (DEFAULT);
SELECT x AS sf_val FROM t4 WHERE x > 42 \gset
SELECT :sf_val < x AS is_growing FROM t5 WHERE x > 42;

-- Test INCREMENT
CREATE TABLE t6(x bigserial, y int);
INSERT INTO t6 VALUES (DEFAULT, 10);
INSERT INTO t6 VALUES (DEFAULT, 20);
SELECT * FROM t6;
INSERT INTO t6 VALUES (DEFAULT, 30);
SELECT * FROM t6;
SELECT snowflake.convert_sequence_to_snowflake('t6_x_seq');
-- Get the count portion of the id.
-- It happens within the same milisecond, should increment
SELECT snowflake.get_count(snowflake.nextval('t6_x_seq'))
UNION ALL
SELECT snowflake.get_count(snowflake.nextval('t6_x_seq'))
UNION ALL
SELECT snowflake.get_count(snowflake.nextval('t6_x_seq'));

-- Should return 1 (the counter difference)
SELECT ABS(snowflake.nextval('t6_x_seq') - snowflake.nextval('t6_x_seq'));

-- If < 4096, will increment that amount
ALTER SEQUENCE t6_x_seq INCREMENT 100 NO MAXVALUE;
SELECT snowflake.get_count(snowflake.nextval('t6_x_seq'))
UNION ALL
SELECT snowflake.get_count(snowflake.nextval('t6_x_seq'))
UNION ALL
SELECT snowflake.get_count(snowflake.nextval('t6_x_seq'));

-- This will force the time ms portion to increment,
-- the count portion should be 0
ALTER SEQUENCE t6_x_seq INCREMENT 4096;
SELECT snowflake.get_count(snowflake.nextval('t6_x_seq'))
UNION ALL
SELECT snowflake.get_count(snowflake.nextval('t6_x_seq'))
UNION ALL
SELECT snowflake.get_count(snowflake.nextval('t6_x_seq'));

-- should return 1 (the ms difference)
SELECT ABS(snowflake.nextval('t6_x_seq') - snowflake.nextval('t6_x_seq')) >> 22;

-- Test unreasonable value- still should get 0s
ALTER SEQUENCE t6_x_seq INCREMENT 9999;
SELECT snowflake.get_count(snowflake.nextval('t6_x_seq'))
UNION ALL
SELECT snowflake.get_count(snowflake.nextval('t6_x_seq'))
UNION ALL
SELECT snowflake.get_count(snowflake.nextval('t6_x_seq'));

-- should return 1 (the ms difference)
SELECT ABS(snowflake.nextval('t6_x_seq') - snowflake.nextval('t6_x_seq')) >> 22;

-- Cleanup
DROP TABLE t1,t2,t3,t4,t5,t6 CASCADE;
DROP SEQUENCE favorite_seq;
DROP EXTENSION snowflake;
